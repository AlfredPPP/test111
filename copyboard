你提到了一个非常好的问题。在实际开发过程中，通常我们希望通过 PySide2 Designer 创建的 UI 文件生成一个 `.ui` 文件，然后通过 `pyside2-uic` 工具将其转化为 Python 代码，这样我们就可以在脚本中直接使用这些已经设计好的控件，而无需手动再写一遍。

让我解释一下你应该如何利用 PySide2 Designer 和生成的 Python 代码，而避免手动再创建 UI 元素。

### 1. **使用 PySide2 Designer 创建 UI**
   - 通过 PySide2 Designer 设计你的界面，包括添加 `QTableWidget`、按钮等元素，并保存为一个 `.ui` 文件（例如 `main_window.ui`）。

### 2. **将 `.ui` 文件转换为 Python 文件**
   - 使用以下命令将 `.ui` 文件转换为 Python 文件：
     ```bash
     pyside2-uic main_window.ui -o ui_mainwindow.py
     ```
   - 这会生成一个 `ui_mainwindow.py` 文件，其中包含了由 Designer 设计的所有控件的定义。

### 3. **在 Python 脚本中使用生成的 UI 代码**
   - 你可以通过继承生成的 `Ui_MainWindow` 类，并将其与主窗口绑定。这样，你就不需要手动再编写表格和按钮的创建代码。

   下面是更新后的代码示例，展示如何利用 Designer 生成的代码：

```python
import sys
import threading
from PySide2.QtWidgets import QMainWindow, QApplication, QTableWidgetItem, QCheckBox, QProgressBar
from PySide2.QtCore import Qt, QMetaObject, Q_ARG
from ui_mainwindow import Ui_MainWindow  # 导入由pyside2-uic生成的UI代码

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()  # 创建UI实例
        self.ui.setupUi(self)  # 绑定UI到当前窗口

        # Connect buttons to functions
        self.ui.submit_button.clicked.connect(self.on_submit_clicked)
        self.ui.get_cusip_button.clicked.connect(self.on_get_cusip_clicked)

    def on_submit_clicked(self):
        # 模拟加载数据
        files = [
            ("AMIT Distribution Report Mock Up 16th July.xlsx", "PTEM", "PT002", "Not Found"),
            ("Distribution No-Post Post Report NoPost.xlsx", "WAMX", "WM001", "Not Found"),
            ("non AMIT Distribution Report Mock Up 16th July.xlsx", "PT3F", "PT003", "Not Found"),
            ("TEST.xlsx", "PIT1", "FR013", "Not Found")
        ]

        self.ui.tableWidget.setRowCount(len(files))

        for i, file_data in enumerate(files):
            # 添加选择框
            checkbox = QCheckBox()
            self.ui.tableWidget.setCellWidget(i, 0, checkbox)

            # 添加文件信息
            for j, item in enumerate(file_data):
                table_item = QTableWidgetItem(item)
                self.ui.tableWidget.setItem(i, j + 1, table_item)

            # 添加 Cusip 和 Status 列
            self.ui.tableWidget.setItem(i, 5, QTableWidgetItem("Not Found"))
            self.ui.tableWidget.setItem(i, 6, QTableWidgetItem("Not Found"))

    def on_get_cusip_clicked(self):
        # 获取勾选的行并执行模拟的 cusip 获取过程
        for i in range(self.ui.tableWidget.rowCount()):
            checkbox = self.ui.tableWidget.cellWidget(i, 0).layout().itemAt(0).widget()
            if checkbox.isChecked():
                self.start_spinner(i)
                threading.Thread(target=self.simulate_cusip_fetch, args=(i,)).start()

    def simulate_cusip_fetch(self, row):
        # 模拟获取 Cusip 的过程
        time.sleep(2)  # 模拟网络延迟
        cusip = "12345678"  # 模拟返回的 Cusip

        # 在主线程中更新 UI
        QApplication.instance().postEvent(self, lambda: self.update_row(row, cusip))

    def start_spinner(self, row):
        # 显示进度条（或者使用Spinner）
        progress_bar = QProgressBar(self)
        progress_bar.setRange(0, 0)  # 无限模式
        self.ui.tableWidget.setCellWidget(row, 6, progress_bar)

    def update_row(self, row, cusip):
        # 更新 Cusip 和状态
        self.ui.tableWidget.setItem(row, 5, QTableWidgetItem(cusip))
        self.ui.tableWidget.setItem(row, 6, QTableWidgetItem("Completed"))

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
```

### 4. **解释代码**
- **`Ui_MainWindow` 类**：这是由 PySide2 Designer 生成的类，包含了设计时创建的所有控件。你可以通过 `self.ui.tableWidget` 直接访问 `QTableWidget`，无需手动创建。
- **代码逻辑**：你仍然可以在脚本中编写逻辑，如在 `Submit` 按钮点击后加载数据，或在 `Get Cusip` 按钮点击后动态更新表格。

这样，你在 Designer 中设计的 UI 元素会直接通过 `Ui_MainWindow` 类应用到你的主窗口上，避免了手动重复创建界面的代码。