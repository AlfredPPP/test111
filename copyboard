The error you're encountering, `"QObject::setParent: Cannot set parent, new parent is in a different thread"`, is typically due to trying to interact with Qt GUI elements from a different thread than the one they were created in. In Qt (and many GUI frameworks), UI components can only be safely manipulated from the main GUI thread.

### Understanding the Problem

In your case, it sounds like you're trying to display a message box (`QMessageBox.information`) directly from within a worker thread that handles the login operation. This is what's likely causing the issue. Even if you're creating a new `QMessageBox` within the thread, it still counts as GUI interaction, which Qt restricts to the main thread to ensure thread safety.

### Solution

To resolve this issue, you'll need to signal back to the main thread to perform any UI updates or interactions. In PySide2, you can use signals and slots to achieve this safely. Hereâ€™s how you can modify your implementation:

1. **Define a Signal:**
   You need to define a custom signal in your worker class that can be emitted when you want to show the message box.

2. **Connect the Signal to a Slot in the Main Thread:**
   This slot will be responsible for displaying the message box.

3. **Emit the Signal from the Worker Thread:**

Here's an example of how you can set this up:

```python
from PySide2.QtCore import QObject, Signal, Slot
from PySide2.QtWidgets import QMessageBox

class Worker(QRunnable):
    login_success = Signal(str)  # Signal to indicate login success

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    def run(self):
        # Assuming `self.fn` performs the login and returns a success message
        result_message = self.fn(*self.args, **self.kwargs)
        self.login_success.emit(result_message)  # Emit the signal with the result

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        # Setup UI and other components here...
        self.thread_pool = QThreadPool()
        # Connect worker's signal to a slot
        self.worker = Worker(self.login)
        self.worker.login_success.connect(self.show_login_result)

    @Slot(str)
    def show_login_result(self, message):
        QMessageBox.information(self, "Login", message)

    def login(self, username, password):
        # Perform login logic here
        session = dmh_session(username, password)
        # Return a message based on login success or failure
        return "Login successful!" if session.is_logged_in else "Login failed"

    # Add logic to start the worker
    def start_login(self):
        username = "your_username"
        password = "your_password"
        self.thread_pool.start(Worker(self.login, username, password))
```

### Summary

- Ensure all GUI interactions happen on the main thread.
- Use signals and slots to communicate between threads.
- Modify the worker to emit a signal when it needs to update the UI or display a message.

This approach ensures that your application adheres to Qt's threading and GUI update requirements, preventing cross-thread GUI manipulation errors.