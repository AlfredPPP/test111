将多线程的部分改为使用 `asyncio` 可以减少复杂性，并且利用 Python 标准库中的功能。下面是你提供的代码的改写版本，其中将 `QRunnable` 和 `QThreadPool` 替换为了 `asyncio` 的异步任务管理。

```python
import sys
import os
import asyncio
from PySide2.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QPushButton, QLineEdit, QLabel, QMessageBox
from PySide2.QtCore import Slot
from ui_mainwindow import Ui_MainWindow

import requests  # To handle HTTP requests

class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setWindowTitle("HiTrust Handler")
        self.setGeometry(100, 100, 800, 600)  # x, y, width, height

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)

        self.setupUi(self)

        self.login_button.clicked.connect(self.on_login_clicked)
        self.log_button.clicked.connect(self.on_log_clicked)
        self.submit_button.clicked.connect(self.on_submit_clicked)
        self.cusip_button.clicked.connect(self.on_cusip_clicked)
        self.import_button.clicked.connect(self.on_import_clicked)

        self.dmh_session = None

    @Slot(str)
    def show_box_message(self, message):
        QMessageBox.information(self, 'HiTrust Handler', message)

    async def login(self, username, password):
        # 模拟异步登录操作，这里你可以替换成真实的异步网络请求
        await asyncio.sleep(2)
        return f"Logged in as {username}"

    @Slot()
    def on_login_clicked(self):
        username = self.username_input.text()
        password = self.password_input.text()

        asyncio.create_task(self.handle_login(username, password))

    async def handle_login(self, username, password):
        message = await self.login(username, password)
        self.show_box_message(message)

if __name__ == '__main__':
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
    from dmh_handler.dmh_session import dmh_session
    from source_file_handler.parser import hi_trust_parser
    from utils.helpers import copy_files_to_local, get_cache_directory
    from utils.logger import get_log_file_path, logger, log_exception
    
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    
    loop = asyncio.get_event_loop()
    loop.run_until_complete(loop.create_task(asyncio.sleep(0)))  # 这行确保事件循环不会立即退出
    sys.exit(app.exec_())
```

### 主要改动：

1. **移除了 `QRunnable` 和 `QThreadPool`**：这些类用于多线程处理，现已替换为 `asyncio` 提供的异步任务机制。
  
2. **改用 `asyncio.create_task` 创建异步任务**：在点击登录按钮时，创建了一个异步任务来处理登录过程。

3. **`login` 方法变为异步函数**：使用 `async def` 定义，并在内部模拟异步操作（例如网络请求）时使用 `await asyncio.sleep(2)`。

4. **事件循环**：确保 `asyncio` 的事件循环与 Qt 的事件循环共同运行。这里使用了 `loop.run_until_complete` 来启动一个虚拟任务，避免事件循环在 `sys.exit(app.exec_())` 调用之前退出。

### 注意事项：

- 你可能需要将实际的同步请求替换为 `aiohttp` 或类似的异步库来实现真正的异步请求。
- 在将整个代码改为异步之后，最好检查与 UI 相关的部分，确保没有阻塞操作会影响 UI 的响应速度。