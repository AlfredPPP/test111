为了让登录和下载功能在异步模式下独立触发并共享会话状态，需要在 GUI 应用中合理管理异步事件循环和会话对象。以下是分步解决方案：

---

### 1. 创建异步管理器类（处理事件循环）
```python
# async_manager.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncManager:
    def __init__(self):
        self.loop = asyncio.new_event_loop()
        self.executor = ThreadPoolExecutor(max_workers=1)
        
    def run_async_task(self, coro):
        """在后台线程运行异步任务"""
        future = self.loop.run_in_executor(
            self.executor,
            lambda: self.loop.run_until_complete(coro)
        )
        return future
```

---

### 2. 修改异步处理器类（保持会话状态）
```python
# my_rts_handler.py
import aiohttp
import aiofiles
import os

class MyRTSHandler:
    def __init__(self):
        self.session = None
        self.is_signed = False

    async def login(self, username, password):
        """独立登录方法"""
        if self.session and not self.session.closed:
            await self.session.close()
            
        self.session = aiohttp.ClientSession()
        login_url = 'https://myrts.com/login'
        
        async with self.session.post(
            login_url,
            data={'username': username, 'password': password}
        ) as res:
            self.is_signed = res.status == 200

    async def download_45days_csv(self, export_path, date, funds):
        """需要先登录才能调用的下载方法"""
        if not self.is_signed:
            raise RuntimeError("Not logged in")
            
        # 保持原有下载逻辑...
        # （使用 self.session 进行请求）
```

---

### 3. 在 PySide2 界面中的集成
```python
# main_window.py
from PySide2.QtWidgets import QMainWindow, QPushButton
from async_manager import AsyncManager
from my_rts_handler import MyRTSHandler

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # 初始化异步系统
        self.async_manager = AsyncManager()
        self.handler = MyRTSHandler()
        
        # 创建界面组件
        self.login_btn = QPushButton("Login", self)
        self.download_btn = QPushButton("Download", self)
        
        # 绑定事件
        self.login_btn.clicked.connect(self.on_login)
        self.download_btn.clicked.connect(self.on_download)
        
    def on_login(self):
        """登录按钮点击事件"""
        future = self.async_manager.run_async_task(
            self.handler.login("user", "pass")
        )
        future.add_done_callback(
            lambda _: print("Login status:", self.handler.is_signed)
        )
        
    def on_download(self):
        """下载按钮点击事件"""
        if not self.handler.is_signed:
            print("请先登录！")
            return
            
        future = self.async_manager.run_async_task(
            self.handler.download_45days_csv(
                "./data",
                "2023-01-01",
                ["0001", "0002"]
            )
        )
        future.add_done_callback(
            lambda _: print("下载完成！")
        )
```

---

### 4. 关键实现细节说明

#### 会话状态保持
- `MyRTSHandler` 实例在窗口生命周期内持续存在
- 登录时创建新的 `ClientSession` 并保留引用
- 下载时复用已存在的会话对象

#### 异步任务调度
- 使用独立线程运行事件循环（避免阻塞GUI线程）
- `AsyncManager` 封装了线程安全的异步任务调度
- 通过 `run_async_task` 方法提交协程任务

#### 线程安全注意事项
- GUI 回调中不直接访问异步对象
- 通过 `future.add_done_callback` 处理完成通知
- 使用 `ThreadPoolExecutor` 确保单一线程执行异步任务

#### 错误处理建议
```python
# 在 run_async_task 中添加错误处理
def run_async_task(self, coro):
    async def wrapped():
        try:
            return await coro
        except Exception as e:
            print(f"Async error: {str(e)}")
            return None
            
    future = self.loop.run_in_executor(
        self.executor,
        lambda: self.loop.run_until_complete(wrapped())
    )
    return future
```

---

### 5. 部署注意事项

1. 安装必要依赖：
```bash
pip install aiohttp aiofiles PySide2
```

2. 启动GUI时初始化异步系统：
```python
if __name__ == "__main__":
    app = QApplication()
    window = MainWindow()
    window.show()
    app.exec_()
    # 程序退出时清理异步资源
    window.async_manager.executor.shutdown()
```

3. 会话超时处理建议：
```python
# 在 MyRTSHandler 中添加会话刷新逻辑
async def check_session(self):
    if self.session and self.session.closed:
        await self.login(last_username, last_password)
```

---

这种设计模式实现了：
- 登录/下载功能的完全异步化
- 会话状态的持久化保持
- GUI线程与异步任务的解耦
- 安全的跨线程异步操作
- 可扩展的错误处理机制
